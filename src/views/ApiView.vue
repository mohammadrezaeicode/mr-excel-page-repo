<template>
  <v-container ref="root">
    <h1 id="introduction">API</h1>
    <p>
      In the API, you will discover various options and configurations that you can utilize within
      the library.
    </p>
    <h2 id="excel-table-object">ExcelTable Object</h2>
    <p>
      Certainly! Here's a table describing the properties associated with the root of the
      <b>generateExcel</b> function input:
    </p>
    <TableComponent :rows="dataRel.table.rows"></TableComponent>
    <p>
      These properties allow you to customize various aspects of the Excel file generated by the
      <b>generateExcel</b> function.
    </p>
    <h2 id="styles-object">Styles Object</h2>
    <p>
      To define the styling for your Excel file, you should utilize this option. The
      <b>Styles</b> object allows you to specify various formatting properties that will be applied
      to cells in the generated Excel file. Each property in the object corresponds to a specific
      style element, such as foreground color, font color, font family, size, alignment, border, and
      format. You can customize these properties according to your preferences to achieve the
      desired visual appearance for your Excel document.
    </p>
    <div class="d-flex">
      <div class="pre mb-auto pa-2 mr-1 my-auto">
        <pre>
[key: string]: {
    fg?: string;
    fontColor?:string;
    fontFamily?:string;
    size?: number;
    index?: number;
    alignment?: 
       AlignmentOption;
    border?:BorderOption;
    format: string;
}</pre>
      </div>
      <TableComponent :rows="dataRel.styles.rows"></TableComponent>
    </div>
    <h2 id="sheet-object">Sheet Object</h2>
    <p>
      The Sheet object is used to define various options related to a specific sheet within the
      Excel file. It holds a significant role and can be considered as one of the most crucial
      options.
    </p>
    <TableComponent :rows="dataRel.sheet.rows"></TableComponent>
    <p>
      These properties allow you to customize the behavior and appearance of individual sheets
      within the Excel file generated using the library. You can set headers, apply formulas, define
      styles, manage merging cells, specify visibility, and much more to create Excel sheets that
      match your specific requirements.
    </p>
    <h2 id="border-object">Border Object</h2>
    <p>
      If you intend to add borders to your Excel cells, you can utilize this BorderOption object. It
      provides a convenient way to define border properties for various border directions.
    </p>
    <TableComponent :rows="dataRel.border.rows"></TableComponent>
    <p>
      This object allows you to specify the color and style of borders for different directions,
      such as top, left, right, bottom, and full. By incorporating the BorderOption, you can enhance
      the visual appearance of your Excel tables with well-defined and aesthetically pleasing cell
      borders.
    </p>
    <h2 id="formula-object">Formula Object</h2>
    <p>
      The Formula Object provides a way to define formulas for Excel cells. It consists of the
      following properties
    </p>
    <div class="d-flex">
      <div class="pre mb-auto pa-2 mr-1 my-auto">
        <pre>
[insertCell: string]:{ 
    type: FormulaType;
    start: string;
    end: string;
    styleId?: string;
}</pre>
      </div>
      <TableComponent :rows="dataRel.formula.rows"></TableComponent>
    </div>
    <p>
      In the above example, we've defined formulas for different cells using the Formula Object. You
      can specify the formula type, start and end cell, and even apply a specific style to the
      formula cells if desired.
    </p>
    <h2 id="alignment-options">Alignment Object</h2>
    <p>
      The library provides several options for aligning cells, allowing you to control how the
      content is displayed within cells. These alignment options can be configured using the
      following properties:
    </p>
    <TableComponent :rows="dataRel.alignment.rows"></TableComponent>
    <p>
      You can use these alignment options to customize the appearance of cell content within your
      Excel sheets. Adjusting these properties allows you to control the positioning, orientation,
      and overall style of the data in your cells.
    </p>
    <h2 id="side-by-side">Side by Side / line by line Object</h2>
    <p>This object is used as input for the<b>sideBySideLineByLine</b> Function
    </p>
    <TableComponent :rows="dataRel.side.rows"></TableComponent>
    <h2 id="side-by-side">Data models</h2>
    <p class="mb-2">Some of the data models that are being used include:</p>
    <div class="pre mb-auto pa-2 mr-1 my-auto">
      <pre>
export type ProtectionOption = {
  [key in ProtectionOptionKey]: "0" | "1" | 0 | 1;
};
export interface ImageTypes {
  url: string;
  from: string;
  to?: string;
  type?: "one" | "two";
  extent?: {
    cx: number;
    cy: number;
  };
  margin?: {
    all?: number;
    right?: number;
    left?: number;
    bottom?: number;
    top?: number;
  };
}
export interface SideBySide {
  sheetName?: string;
  spaceX?: number;
  spaceY?: number;
  headers: { label: string; text: string }[];
  data: Data[];
  headerIndex?: number;
}
export type ProtectionOptionKey =
  | "sheet"
  | "formatCells"
  | "formatColumns"
  | "formatRows"
  | "insertColumns"
  | "insertRows"
  | "insertHyperlinks"
  | "deleteColumns"
  | "deleteRows"
  | "sort"
  | "autoFilter"
  | "pivotTables";

export type AlignmentOptionKey =
  | "horizontal"
  | "vertical"
  | "wrapText"
  | "shrinkToFit"
  | "readingOrder"
  | "textRotation"
  | "indent";
export interface AlignmentOption {
  horizontal?: "center" | "left" | "right";
  vertical?: "center" | "top" | "bottom";
  wrapText?: "0" | "1" | 2 | 1;
  shrinkToFit?: "0" | "1" | 2 | 1;
  readingOrder?: "1" | "2" | 2 | 1;
  textRotation?: number;
  indent?: number;
  rtl?: boolean;
  ltr?: boolean;
}
export type BorderDirection = "full" | "top" | "left" | "right" | "bottom";
export type BorderOption = {
  [key in BorderDirection]?: {
    color: string;
    style:
      | "slantDashDot"
      | "dotted"
      | "thick"
      | "hair"
      | "dashDot"
      | "dashDotDot"
      | "dashed"
      | "thin"
      | "mediumDashDot"
      | "medium"
      | "double"
      | "mediumDashed";
  };
};
export interface Header {
  label: string;
  text: string;
  size?: number;
  multiStyleValue?: MultiStyleValue;
  comment?: Comment | string;
  formula?: {
    type: FormulaType;
    styleId?: string;
  };
}

export interface Data extends DataOptions {
  [key: string]: string | number | any | undefined;
}
export interface MultiStyleRexValue {
  reg: RegExp | string;
  styleId: string;
}
export interface Comment {
  comment?: string;
  styleId?: string;
  author?: string;
}
export interface MultiStyleValue {
  [key: string]: string | undefined | MultiStyleRexValue[];
  reg?: MultiStyleRexValue[];
}
export interface MapMultiStyleValue {
  [key: string]: MultiStyleValue;
}
export interface MapComment {
  [key: string]: Comment | string;
}
export interface DataOptions {
  [key: string]:
    | "0"
    | "1"
    | number
    | string
    | undefined
    | MapComment
    | MapMultiStyleValue;
  outlineLevel?: number;
  hidden?: "0" | "1" | number;
  rowStyle?: string;
  height?: number;
  multiStyleValue?: MapMultiStyleValue;
  comment?: MapComment;
}
export interface MergeRowConditionMap {
  [columnKey: string]: {
    inProgress: boolean;
    start: number;
  };
}
export type MultiStyleConditinFunction = (
  data: Header | string | number | undefined,
  object: null | Data,
  headerKey: string,
  rowIndex: number,
  colIndex: number,
  fromHeader: boolean
) => MultiStyleValue | null;

export type CommentConditionFunction = (
  data: Header | string | number | undefined,
  object: null | Data,
  headerKey: string,
  rowIndex: number,
  colIndex: number,
  fromHeader: boolean
) => Comment | string | false | undefined | null;
export type StyleCellConditionFunction = (
  data: Header | string | number | undefined,
  object: Header | Data,
  colIndex: number,
  rowIndex: number,
  fromHeader: boolean,
  stylekeys: string[]
) => string | null;
export type MergeRowDataConditionFunction = (
  data: Header | string | number | undefined,
  key: string | null,
  index: number,
  fromHeader: boolean
) => boolean;
export interface SortAndFilter {
  mode: "all" | "ref";
  ref?: string;
}
export interface Title {
  shiftTop?: number;
  shiftLeft?: number;
  consommeRow?: number;
  consommeCol?: number;
  height?: number;
  styleId?: string;
  text?: string;
  multiStyleValue?: MultiStyleValue;
  comment?: Comment | string;
}
export interface SheetOption {
  withoutHeader?: boolean;
  multiStyleConditin?: MultiStyleConditinFunction;
  useSplitBaseOnMatch?: boolean;
  images?: ImageTypes[];
  formula?: Formula;
  name?: string;
  title?: Title;
  shiftTop?: number;
  shiftLeft?: number;
  selected?: boolean;
  tabColor?: string;
  merges?: string[];
  headerStyleKey?: string;
  mergeRowDataCondition?: MergeRowDataConditionFunction;
  styleCellCondition?: StyleCellConditionFunction;
  commentCodition?: CommentConditionFunction;
  sortAndfilter?: SortAndFilter;
  state?: "hidden" | "visible";
  headerRowOption?: any;
  protectionOption?: ProtectionOption;
  headerHeight?: number;
}
export interface Sheet extends SheetOption {
  headers: Header[];
  data: Data[];
}
export interface HeaderRowOption {
  outlineLevel: "string";
}
export interface StyleMapper {
  commentSintax: {
    value: {
      [key: string]: string;
    };
  };
  format: {
    count: number;
    value: string;
  };
  border: {
    count: number;
    value: string;
  };
  fill: {
    count: number;
    value: string;
  };
  font: {
    count: number;
    value: string;
  };
  cell: {
    count: number;
    value: string;
  };
}
export type FormulaType = "AVERAGE" | "SUM" | "COUNT" | "MAX" | "MIN";
export interface StyleBody {
  fg?: string;
  fontColor?: string;
  fontFamily?: string;
  size?: number;
  index?: number;
  alignment?: AlignmentOption;
  border?: BorderOption;
  format?: string;
  bold?: boolean;
  underline?: boolean;
  italic?: boolean;
  doubleUnderline?: boolean;
}
export interface Styles {
  [key: string]: StyleBody;
}
export interface FormatMap {
  [format: string]: {
    key: number;
    value?: string;
  };
}
export interface FormulaSetting {
  type: FormulaType;
  start: string;
  end: string;
  styleId?: string;
}
export interface Formula {
  [insertCell: string]: FormulaSetting;
}
export interface Theme extends ExcelTableOption {
  sheet: SheetOption[];
}
export interface ExcelTableOption {
  notSave?: boolean;
  creator?: string;
  backend?: boolean;
  fileName?: string;
  generateType?: "nodebuffer" | "array" | "binarystring" | "base64";
  addDefaultTitleStyle?: boolean;
  created?: string;
  modified?: string;
  numberOfColumn?: number;
  createType?: string;
  mapSheetDataOption?: any;
  styles?: Styles;
}
export interface ExcelTable extends ExcelTableOption{
  sheet: Sheet[];
}</pre>
    </div>
  </v-container>
</template>
<script setup>
import {
  onMounted,
  reactive,
  // reactive,
  ref
} from 'vue'
// import codeJson from '../strings/code.json'
// import CodeSection from '../components/code/codeSection.vue'
// import { ex1, ex } from '../dataset/example'
// import { generateExample } from '../utils/generate'
import { useSelectStore } from '@/stores/select'
import TableComponent from '@/components/table/TableComponent.vue'
const root = ref(null)
const dataRel = reactive({
  table: {
    rows: [
      {
        name: 'notSave?',
        type: 'boolean',
        des: `Controls whether the generated Excel file should be saved.`
      },
      { name: 'creator?', type: 'string', des: `Specifies the creator of the Excel file.` },
      { name: 'created?', type: 'string', des: `Sets the creation date of the Excel file.` },
      { name: 'modified?', type: 'string', des: `Sets the modification date of the Excel file.` },
      {
        name: 'numberOfColumn?',
        type: 'number',
        des: `number	Specifies the number of columns in the Excel file.`
      },
      {
        name: 'createType?',
        type: 'string',
        des: `Specifies the type of creation for the Excel file.`
      },
      {
        name: 'mapSheetDataOption?',
        type: 'any',
        des: `An option to define the type if needed for mapping sheet data.`
      },
      {
        name: '<a href="#styles-object">styles?</a>',
        type: 'Styles',
        des: `Defines the styles to be applied to the Excel cells.`
      },
      {
        name: '<a href="#sheet-object">sheet</a>',
        type: 'Sheet[]',
        des: `An array of sheets containing data and configuration settings.`
      }
    ]
  },
  styles: {
    rows: [
      { name: 'fg?', type: 'string', des: 'Specifies the foreground color of the cell text.' },
      { name: 'fontColor?', type: 'string', des: 'Defines the font color of the cell text.' },
      { name: 'fontFamily?', type: 'string', des: 'Sets the font family for the cell text.' },
      { name: 'size?', type: 'number', des: 'Specifies the font size of the cell text.' },
      { name: 'index?', type: 'number', des: 'Specifies the index of the style.' },
      {
        name: 'alignment?',
        type: 'AlignmentOption',
        des: 'AlignmentOption	Defines the cell alignment properties (horizontal and vertical).'
      },
      { name: 'border?', type: 'BorderOption', des: 'Specifies the border style for the cell.' },
      {
        name: 'format',
        type: 'string',
        des: 'Determines the format of the cell content, such as date, time, currency, etc.'
      }
    ]
  },
  sheet: {
    rows: [
      {
        name: 'withoutHeader?',
        type: 'boolean',
        des: 'Specifies whether the sheet should be generated without a header row.'
      },
      { name: 'formula?', type: 'Formula', des: 'Defines formulas to be applied to the sheet.' },
      { name: 'name?', type: 'string', des: 'Sets the name of the sheet.' },
      {
        name: 'selected?',
        type: 'boolean',
        des: 'Determines if the sheet is selected when the Excel file is opened.'
      },
      { name: 'tabColor?', type: 'string', des: 'Specifies the tab color of the sheet.' },
      { name: 'merges?', type: 'string[]', des: 'Defines merged cell ranges within the sheet.' },
      {
        name: 'headerStyleKey?',
        type: 'string',
        des: 'Sets the style for the header cells using a style ID.'
      },
      {
        name: 'mergeRowDataCondition?',
        type: 'MergeRowDataConditionFunction',
        des: 'Defines a condition for merging rows.'
      },
      {
        name: 'styleCellCondition?',
        type: 'StyleCellConditionFunction',
        des: 'Sets styling conditions for individual cells.'
      },
      {
        name: 'sortAndfilter',
        type: 'SortAndFilter',
        des: 'Defines sorting and filtering options for the sheet.'
      },
      {
        name: 'state',
        type: '"hidden" | "visible"',
        des: 'Determines the visibility of the sheet.'
      },
      {
        name: 'headerRowOption?',
        type: 'any',
        des: 'Allows the definition of header row options (type to be defined if needed).'
      },
      {
        name: 'protectionOption?',
        type: 'ProtectionOption',
        des: 'Specifies protection options for the sheet.'
      },
      { name: 'headerHeight?', type: 'number', des: 'Sets the height of the header row.' },
      { name: 'headers', type: 'Header[]', des: 'Defines the headers for the sheet columns.' },
      { name: 'data', type: 'Data[]', des: 'Provides the data entries for the sheet.' }
    ]
  },
  border: {
    rows: [
      {
        name: 'key',
        type: 'string',
        des: 'BorderDirection value indicating the direction of the border. Possible values include: "full", "top", "left", "right", and "bottom".'
      },
      {
        name: 'color',
        type: 'string',
        des: 'The color of the border. Specify a valid color code or name.'
      },
      {
        name: 'style',
        type: `"slantDashDot"|"dotted"|
"thick"| "hair"|"dashDot"|
"dashDotDot"| "dashed"| "thin"|
"mediumDashDot"| "medium"|
"double"| "mediumDashed"`,
        des: 'The style of the border. Choose from styles such as "slantDashDot", "dotted", "thick", "hair", "dashDot", "dashDotDot", "dashed", "thin", "mediumDashDot", "medium", "double", and "mediumDashed".'
      }
    ]
  },
  formula: {
    rows: [
      {
        name: 'insertCell',
        type: 'string',
        des: 'A string representing the cell where the formula will be inserted.'
      },
      {
        name: 'type',
        type: '"AVERAGE" | "SUM" | "COUNT" | "MAX" | "MIN"',
        des: 'The type of formula to apply. Choose from FormulaType options such as "AVERAGE", "SUM", "COUNT", "MAX", and "MIN".'
      },
      { name: 'start', type: 'string', des: 'The starting cell for the formula range.' },
      { name: 'end', type: 'string', des: 'The ending cell for the formula range.' },
      {
        name: 'styleId',
        type: 'string',
        des: '(Optional) The style ID to be applied to cells containing the formula. Use this if you want to style formula cells.'
      }
    ]
  },
  alignment: {
    rows: [
      {
        name: 'horizontal?',
        type: ' "center" | "left" | "right";',
        des: 'The horizontal alignment of cell content. Choose from "center", "left", or "right".'
      },
      {
        name: 'vertical?',
        type: ' "bottom" | "top" | "bottom";',
        des: 'The vertical alignment of cell content. Choose from "bottom", "top", or "bottom".'
      },
      {
        name: 'wrapText?',
        type: ' "0" | "1";',
        des: 'Whether to wrap text within cells. Use "0" for false or "1" for true.'
      },
      {
        name: 'shrinkToFit?',
        type: ' "0" | "1";',
        des: 'Whether to shrink cell content to fit within the cell. Use "0" for false or "1" for true.'
      },
      {
        name: 'readingOrder?',
        type: ' "1" | "2" | 2 | 1;',
        des: 'The reading order of the cell content. Choose from "1" (left to right) or "2" (right to left).'
      },
      {
        name: 'textRotation?',
        type: ' number;',
        des: 'The degree of text rotation within cells. Can be a number representing the rotation angle.'
      },
      {
        name: 'indent?',
        type: ' number;',
        des: 'The indentation level of cell content. Use a number to specify the indent.'
      },
      {
        name: 'rtl?',
        type: ' boolean;',
        des: 'Whether the cell content should be displayed right-to-left. Use "true" for right-to-left alignment.'
      },
      {
        name: 'ltr?',
        type: ' boolean;',
        des: 'Whether the cell content should be displayed left-to-right. Use "true" for left-to-right alignment.'
      }
    ]
  },
  side: {
    rows: [
      {
        name: 'sheetName?',
        type: 'string',
        des: 'A string representing the name of the sheet. (Optional)'
      },
      {
        name: 'spaceX?',
        type: 'number',
        des: 'A number indicating the space from the left. (Optional)'
      },
      {
        name: 'spaceY?',
        type: 'number',
        des: 'A number indicating the space from the bottom. (Optional)'
      },
      {
        name: 'headers',
        type: '{label: string; text: string }[]',
        des: 'An array of objects, each containing a `label` (string) and `text` (string), representing the headers of the table.'
      },
      {
        name: 'data',
        type: 'Data[]',
        des: 'An array of `Data` objects, representing the rows of the table.'
      },
    ]
  }
})
let items = []
const select = useSelectStore()
select.setNavBar(2)
const idList = [
  'excel-table-object',
  'styles-object',
  'sheet-object',
  'border-object',
  'formula-object',
  'alignment-options',
  'side-by-side'
]
onMounted(() => {
  idList.forEach((v) => {
    select.setNavBar(2)
    items.push(document.querySelector('#' + v))
  })
  document.body.scrollTop = 0 // For Safari
  document.documentElement.scrollTop = 0 // For Chrome, Firefox, IE and Opera
})
window.addEventListener('scroll', function () {
  let selIndex = -1
  let selTop = -1
  let countNotchoosen = 0
  items.forEach((v, index) => {
    const top = v.getBoundingClientRect().top
    if (top >= 0 && (selTop < 0 || selTop > top)) {
      selTop = top
      selIndex = index
    } else {
      countNotchoosen++
    }
  })
  if (countNotchoosen == items.length) {
    selIndex = items.length - 1
  }
  select.setSelect(selIndex)
})
</script>
<style scoped>
.pre {
  background: var(--c3);
  color: #fadaa9;
  border-radius: 5px;
}
</style>
